---
title: "DESCO - Knowledge Discovery - Association Rules"
author: "1141074 - Sérgio Silva | 1970400 - Pedro Neves | 1040706 - Sérgio Castro"
date: "5/3/2018"
output:
  pdf_document: default
  editor_options: null
  html_document: default
  chunk_output_type: console
bibliography: bibliography.bib
---

```{r Setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, error = TRUE, tidy.opts = list(width.cutoff = 60), tidy = TRUE)
```


```{r Limpeza das variáveis de ambiente, include = FALSE}
rm(list = ls())
```


```{r Bibliotecas necessarias, include=FALSE}
library(data.table)
library(rfm)
library(lubridate)
library(plyr)
library(dplyr)
library(ggplot2)
library(forcats)
library(klaR)
library(arules)
library(arulesViz)

```

Neste documento pretende-se adquirir um melhor conhecimento sobre os perfis de grupos de clientes. Com esta informação, o objetivo final é a recomendação dos artigos mais indicados a cada grupo de clientes.

#1. Exploração e preparação dos dados

Para o cálculo do valor de RFM dos clientes, foi efetuado tratamento dos dados das tabelas **TRANSACTION.dat**, **TRANSACTION_ITEM.dat** e **CARD.DAT**, idêntico ao realizado para a previsão de resposta a campanhas. Detalhes sobre a utilização do algoritmo RFM são descritos na outra parte do trabalho.

```{r Cálculo de valor de RFM para os clientes, include = FALSE}
keycols <- c('Store', 'Date', 'Time', 'TransactionID')

transactions = fread('DATA-CRM/TRANSACTION.dat')
setkeyv(transactions, keycols)

trans.items = fread('DATA-CRM/TRANSACTION_ITEM.dat')
setkeyv(trans.items, keycols)

```

```{r Merge, include = FALSE}
##Fazer 'join' das duas tabelas e remover observações contendo datas inválidas
result.transactions <- merge(transactions, trans.items, all = TRUE)
result.transactions[, Date := as.Date(as.character.Date(Date), "%Y%m%d")]
result.transactions <- na.omit(result.transactions, cols = "Date")
```


```{r RFM algorithm, include = FALSE}
analysis.date <- as.Date("2015-01-01")

orders <- result.transactions[, .(CardID, Date, Amount)]
rfm_result <- rfm_table_order(orders, CardID, Date, Amount, analysis.date)

summary(rfm_result)
str(rfm_result)

```

```{r include = FALSE}
cards = fread("DATA-CRM/CARD.dat", stringsAsFactors = TRUE)
```


```{r include = FALSE}
### Tratar os dados nulos e errados nas colunas NumChildren e YoungestChild , pois tem valores negativos. No MaritalStatus há dados nulos que devem ser tratados também.

cards[NumChildren < 0, NumChildren := 0]
cards[YoungestChild < 0, YoungestChild := 0]
  
# Como existem observações que indicam ter filhos, mas depois o campo do número de filhos está a 0, decidimos alterar o atributo "HasChildren" para "N"
cards[NumChildren == 0 & HasChildren == 'Y', .N]   #13
cards[NumChildren == 0 & HasChildren == 'Y', HasChildren := 'N']

# NumChildren > 0 e HasChildren
cards[NumChildren > 0 & HasChildren == 'N', .N]    #8138
cards[NumChildren > 0 & HasChildren == 'N', HasChildren := 'Y']

# Se não há filhos, colocar YoungestChild <- 0
cards[NumChildren == 0 & HasChildren == 'N', YoungestChild := 0]


# Verificamos que o MaritalStatus possui dados vazios
table(cards$MaritalStatus)

cards[MaritalStatus == "", MaritalStatus := "O"]
cards$MaritalStatus <- droplevels(cards$MaritalStatus)
```


```{r juntar dados dos clientes, include = FALSE}
#Dados dos Cliente
df_customers <- merge(cards, rfm_result$rfm[, c(1, 9)], by.x = 'CardID', by.y = 'customer_id')

df_customers[, CardStartDate := as.Date(as.character.Date(CardStartDate), "%Y%m%d")]
df_customers[, DateOfBirth := as.Date(as.character.Date(DateOfBirth), "%Y%m%d")]

```

```{r criar as colunas com idade e anos de cliente, include = FALSE}

# Calcular Idade do cliente
yr = duration(num = 1, units = "years")
df_customers[, age := round(interval(DateOfBirth, analysis.date)/yr,digits = 0)]

# Anos de cliente
df_customers[, clientYears := round(interval(CardStartDate, analysis.date)/yr,digits = 0)]
```


```{r include = FALSE}

df_customers$Gender <- factor(df_customers$Gender, levels = c("F", "M"), labels = c("Feminino", "Masculino"))
df_customers$MaritalStatus <- factor(df_customers$MaritalStatus, levels = c("M", "S", "O"), labels = c("Casado", "Solteiro", "Outro"))
df_customers$HasChildren <- factor(df_customers$HasChildren, levels = c("Y", "N"), labels = c("Sim","Não"))

df_customers$rfm_score_cat <- case_when(df_customers$rfm_score <= 233 ~ 'Sporadically',
                  between(df_customers$rfm_score, 234, 443) ~ 'Regular',
                  df_customers$rfm_score >= 444 ~ 'Frequent'
                  )

df_customers$rfm_score_cat <- as.factor(df_customers$rfm_score_cat)


```

Ao conjunto de dados resultante, foi adicionado uma categoria para dividir os clientes por intervalos de idades. Os intervalos considerados foram: menor de 50 anos, maior ou igual a 50 e menor de 65 anos, maior ou igual a 65 anos.
```{r }
df_customers$ageInterval <- cut(df_customers$age, 
                      breaks = c(0, 50, 65, +Inf), 
                      labels = c("< 50", "< 65", ">= 65"), 
                      right = FALSE)
```

Verificação dos dados dos clientes.
```{r Dados dos clientes}
summary(df_customers)
```


Para a criação dos *clusters*, foi criado um conjunto de dados com os atributos mais relevantes. A variável 'CardID' é mantida para permitir a identifição das transações após a criação, mas não é utilizado para aquando da criação dos *clusters
```{r}
dataCustomers <- df_customers[, c("CardID", "Region", "Gender", "MaritalStatus", "HasChildren", 
                                   "rfm_score_cat", "clientYears", "age", "ageInterval")]

with(dataCustomers,
  plot( ageInterval, rfm_score_cat, xlab = "Age", ylab = "RFM Score")
  )

```

# 2. Clustering

Como a maioria dos atributos do conjunto de dados são categóricos e o algoritmo **k-means** não é diretamente aplicável a este tipo de dados, é necessário recorrer a outros tipos de algoritmos. Após pesquisa, encontramos algumas soluções que a seguir se descrevem. No entanto, apenas com o algoritmo **k-modes** foi utilizado a totalidade do conjunto de dados.

```{r include = FALSE}
## Determine Best Number of Clusters in Customers Data Set
#library(NbClust)
#library(cluster)

#set.seed(123)

#gower.dist <- daisy(dataCustomers[1:1000, ], metric = "gower")

#nb <- NbClust(diss = gower.dist, distance = NULL, min.nc = 2,
#        max.nc = 10, method = "complete", index ="all")
```


## Model-based Clustering

**VarSelLCM** é um *package* que implementa *clustering* baseado em modelos (deteção das características relevantes e seleção do número de *clusters*), recorrendo a critérios de informação. Dados podem ser compostos por valores contínuosm, inteiros ou numéricos [Ref. @Marbac2017].
Para a criação do cluster, utilizaram-se os atributos 'age' e 'clientYears', que permitiram obter melhores resultados, pelo que não é utilizado o atributo 'ageInterval'.

```{r}
library(VarSelLCM)
set.seed(123)

cluster.model_base <- VarSelCluster(dataCustomers[1:1000, -c("CardID", "ageInterval")], gvals = 3, nbcores = 2)

#VarSelShiny(out)

summary(cluster.model_base)

# As variáveis mais discriminativas do modelo podem ser visualizadas 
plot(cluster.model_base, type = "bar")

# Por exemplo, a distribuição por cluster da variável HasChildren.
plot(cluster.model_base, y = "clientYears", type = "boxplot")
plot(cluster.model_base, y = "HasChildren", type = "boxplot")

# Probabilidades de má classificação
plot(cluster.model_base, type="probs-class")

```
Analisando as duas variáveis mais discriminativas, pode-se verificar que no caso da variável 'clientYears', dois clusters pertencem à mesma gama de valors. No caso da variável 'HasChildren', também se verifica que dois clusters não têm dissemelhança significativa.


## Clustering hierárquico

Novamente, como a maioria dos atributos não são númericos, é necessário utilizar uma métrica que seja adequada a estes dados. Uma possibilidade é a utilização da métrica de Gower [Ref. @Martin]. A função 'daisy()' do package 'cluster' contem uma implementação desta métrica.
Para o calculo da matriz de distância não foram utilizados os atributos 'age' e 'clientYears'.
De notar que a utilização desta métrica obriga a manter uma matriz NxN em memória, o que muito rapidamente se torna , pelo que apenas consideramos um subconjunto dos dados.  

```{r}

library(cluster)
set.seed(123)

gower.dist <- daisy(dataCustomers[1:2000, -c("CardID", "clientYears", "age")], metric = "gower")
summary(gower.dist)

gower.mat <- as.matrix(gower.dist)


# Par mais "semelhante"
dataCustomers[
  which(gower.mat == min(gower.mat[gower.mat != min(gower.mat)]),
        arr.ind = TRUE)[1, ], ]

# Par menos "semelhante"
dataCustomers[
  which(gower.mat == max(gower.mat[gower.mat != max(gower.mat)]),
        arr.ind = TRUE)[1, ], ]


# Clustering hierárquico "divisivo"" (DIANA)
divisive.clust <- diana(as.matrix(gower.dist), diss = TRUE, keep.diss = TRUE)

plot(divisive.clust, main = "Divisivo")

```

```{r include = FALSE}
#A gglomerative (AGNES)
#a gglomerative.clust <- agnes(as.matrix(gower.dist), diss = TRUE, keep.diss = TRUE)

#p lot(agglomerative.clust, main = "Aglomerativo")
```


```{r}
# Clustering PAM (Partition around medoids)
sil_width <- c(NA)

for(i in 2:10) {
  
  pam_fit <- pam(gower.dist, diss = TRUE, k = i)
  
  sil_width[i] <- pam_fit$silinfo$avg.width
}

# Plot sihouette width (higher is better)

plot(1:10, sil_width, xlab = "Número de clusters", ylab = "Silhouette Width")
lines(1:10, sil_width)
```

Considerando este subconjunto de dados, constituído por 2000 observações, o número recomendado de clusters seria 10:
```{r Interpretação dos Clusters}
# ver https://www.r-bloggers.com/clustering-mixed-data-types-in-r/

pam_fit <- pam(gower.dist, diss = TRUE, k = 10)

dataCustomers[pam_fit$medoids, ]


```


## *Clustering* com o algoritmo k-modes
*k-modes* é uma variante do *k-means* que é aplicável a dados categóricos [Ref. @Huang1998].
```{r}

set.seed(123)

# Set number of clusters
kNumberClusters <- 3

# without age and clientYears
clusters.kmodes <- kmodes(dataCustomers[, -c("CardID", "age", "clientYears")], modes = kNumberClusters, iter.max = 10, weighted = FALSE)

# Place customer in its cluster
dataCustomers$cluster <- clusters.kmodes$cluster
clusters <- split(dataCustomers, dataCustomers$cluster)

```

### Visualize differences between clusters
```{r include = FALSE}
dataCustomers[, .N, by = .(cluster, Gender)][order(cluster, Gender)]
dataCustomers[, .N, by = .(cluster, Region)][order(cluster, Region)]
dataCustomers[, .N, by = .(cluster, rfm_score_cat)][order(cluster, rfm_score_cat)]
```

```{r}
barplot(table(dataCustomers$Region, dataCustomers$cluster),
        beside = T, col = c("red", "green"),
        main = "Region by cluster")

barplot(table(dataCustomers$Gender, dataCustomers$cluster),
        beside = T, col = c("red", "green"),
        main = "Gender by cluster")

barplot(table(dataCustomers$MaritalStatus, dataCustomers$cluster),
        beside = T, col = c("red", "green", "blue"),
        main = "MaritalStatus by cluster")

barplot(table(dataCustomers$rfm_score_cat, dataCustomers$cluster),
        beside = T, col = c("red", "green", "blue"),
        main = "RFM Score by cluster")

barplot(table(dataCustomers$HasChildren, dataCustomers$cluster),
        beside = T, col = c("red", "green"),
        main = "HasChildren by cluster")

barplot(table(dataCustomers$ageInterval, dataCustomers$cluster),
        beside = T, col = c("red", "green", "blue"),
        main = "Age by cluster")

```

### Differences between clusters
```{r}
dataCustomers.cl1 <- clusters[[1]]
round(prop.table(table(dataCustomers.cl1$Region))*100, digits = 2)
round(prop.table(table(dataCustomers.cl1$Gender))*100, digits = 2)
round(prop.table(table(dataCustomers.cl1$MaritalStatus))*100, digits = 2)
round(prop.table(table(dataCustomers.cl1$HasChildren))*100, digits = 2)
round(prop.table(table(dataCustomers.cl1$rfm_score_cat))*100, digits = 2)
round(prop.table(table(dataCustomers.cl1$ageInterval))*100, digits = 2)
```

```{r}
dataCustomers.cl2 <- clusters[[2]]
round(prop.table(table(dataCustomers.cl2$Region))*100, digits = 2)
round(prop.table(table(dataCustomers.cl2$Gender))*100, digits = 2)
round(prop.table(table(dataCustomers.cl2$MaritalStatus))*100, digits = 2)
round(prop.table(table(dataCustomers.cl2$HasChildren))*100, digits = 2)
round(prop.table(table(dataCustomers.cl2$rfm_score_cat))*100, digits = 2)
round(prop.table(table(dataCustomers.cl2$ageInterval))*100, digits = 2)
```

```{r}
dataCustomers.cl3 <- clusters[[3]]
round(prop.table(table(dataCustomers.cl3$Region))*100, digits = 2)
round(prop.table(table(dataCustomers.cl3$Gender))*100, digits = 2)
round(prop.table(table(dataCustomers.cl3$MaritalStatus))*100, digits = 2)
round(prop.table(table(dataCustomers.cl3$HasChildren))*100, digits = 2)
round(prop.table(table(dataCustomers.cl3$rfm_score_cat))*100, digits = 2)
round(prop.table(table(dataCustomers.cl3$ageInterval))*100, digits = 2)
```


## Clustering por valor de RFM
Depois de analisados os resultados de aplicação de diferentes algoritmos de *clustering* e atendendo a que os dados são muito desbalanceados, decidimos utilizar como clusters a divisão efetuada pela categorização do *RFM Score* efetuada anteriormente.


```{r}
# Divide customers by its RFM Score
rfm.clusters <- split(dataCustomers, dataCustomers$rfm_score_cat)

dataCustomers.rfmFrequent <- rfm.clusters$Frequent
dataCustomers.rfmRegular <- rfm.clusters$Regular
dataCustomers.rfmSporadically <- rfm.clusters$Sporadically
```


## Processamento dos dados compras

Depois de efetuado o *clustering*, pretende-se agora efetuar o cálculo de regras de associação das transações efetuadas pelos clientes de cada grupo. Para isso, é necessário criar as observações correspondentes aos items e respetiva categorias e subcategorias.

```{r include = FALSE}

## Tabela ITEM.dat
items <- fread("DATA-CRM/ITEM.dat", quote = "'")

### Verificação dos dados da tabela item, tal como o número de colunas e linhas, bem como se os dados foram corretamente carregados.
summary(items)
dim(items)
str(items)

#Verificar se a tabela possui dados nulos
table(is.na(items))


## Tabelas CATEGORY.dat e SUBCATEGORY.dat
categories <- fread("DATA-CRM/CATEGORY.dat", quote = "'")
subcategories <- fread("DATA-CRM/SUBCATEGORY.dat", quote = "'")

```


```{r include = FALSE}
# Join com a tabela de transações + cardID

result.aux <- merge(items, categories, all.x = TRUE, by = 'CategoryCode')
result.aux <- merge(result.aux, subcategories, all.x = TRUE, by = 'SubCategoryCode')

result.purchases <- merge(result.transactions, result.aux[ ,c(3:5, 7:8)], all.x = TRUE, by = 'ItemCode')

# Se retirados 'ItemNumber' e 'TransactionID' passam a existir observações repetidas
dataPurchases <- result.purchases[, c("CardID", "Date", "PaymentMethod", "Amount", "ItemDescription", "CategoryDescription", "SubCategoryDescription", "BrandCode", "ItemNumber", "TransactionID")]


dataPurchases$PaymentMethod <- as.factor(dataPurchases$PaymentMethod)
dataPurchases$ItemDescription <- as.factor(dataPurchases$ItemDescription)
dataPurchases$CategoryDescription <- as.factor(dataPurchases$CategoryDescription)
dataPurchases$SubCategoryDescription <- as.factor(dataPurchases$SubCategoryDescription)
dataPurchases$BrandCode <- as.factor(dataPurchases$BrandCode)


# Split dataPurchases by clusters
dataPurchases.cl1 <- merge(dataPurchases, dataCustomers.cl1[, c("CardID")], by = "CardID")
dataPurchases.cl2 <- merge(dataPurchases, dataCustomers.cl2[, c("CardID")], by = "CardID")
dataPurchases.cl3 <- merge(dataPurchases, dataCustomers.cl3[, c("CardID")], by = "CardID")

```


Depois de processados estes dados, utilizando o particionamento dos clientes pelo *RFM Score* são obtidos os seguintes conjuntos de dados correspondendo a transações efetuadas dos membros de cada grupo.

```{r}

dataPurchases.rfmFrequent <- merge(dataPurchases, dataCustomers.rfmFrequent[, c("CardID")], by = "CardID")
dataPurchases.rfmRegular <- merge(dataPurchases, dataCustomers.rfmRegular[, c("CardID")], by = "CardID")
dataPurchases.rfmSporadically <- merge(dataPurchases, dataCustomers.rfmSporadically[, c("CardID")], by = "CardID")

```

Decidimos utilizar para o cálculo das regras de associação as Subcategorias de produtos, pois, atendendo que existe um número muito elevado de produtos, as diferenças a esse nível não seriam estatisticamente relevantes.

## Vendas por subcategorias de produtos
### Clientes do tipo Regular
```{r}

# Frequência das subcategorias de produtos no cluster ordenado por ordem descrescente
sub_ord_r <- factor(dataPurchases.rfmRegular$SubCategoryDescription,
                  levels = rev(levels(fct_infreq(dataPurchases.rfmRegular$SubCategoryDescription))))

ggplot(as.data.frame(dataPurchases.rfmRegular$SubCategoryDescription), aes(x = sub_ord_r)) +
  geom_bar() + labs(x = "Subcategoria de Produtos", y = "Freq") + labs(title = "Produtos por Clientes tipo 'Regular'") + coord_flip()

```


```{r include = FALSE}
# Alternativamente este gráfico pode ser obtido
x <- as.data.frame(sort(
  table(dataPurchases.rfmRegular$SubCategoryDescription, dnn = c("SubCategory")), decreasing = F))

ggplot(x, aes(x = reorder(SubCategory, Freq), y = Freq)) +
  geom_bar(stat = 'identity') + labs(x = "Sub Category", y = "Freq") + coord_flip()

```

### Clientes do tipo Esporádico
```{r}

# Frequência das subcategorias de produtos no cluster ordenado por ordem descrescente
sub_ord_s <- factor(dataPurchases.rfmSporadically$SubCategoryDescription,
                  levels = rev(levels(fct_infreq(dataPurchases.rfmSporadically$SubCategoryDescription))))

ggplot(as.data.frame(dataPurchases.rfmSporadically$SubCategoryDescription), aes(x = sub_ord_s)) +
  geom_bar() + labs(x = "Subcategoria de Produtos", y = "Freq") + labs(title = "Produtos por Clientes tipo 'Esporádico'") + coord_flip()

```

### Clientes do tipo Frequente
```{r}

# Frequência das subcategorias de produtos no cluster ordenado por ordem descrescente
sub_ord_f <- factor(dataPurchases.rfmFrequent$SubCategoryDescription,
                  levels = rev(levels(fct_infreq(dataPurchases.rfmFrequent$SubCategoryDescription))))

ggplot(as.data.frame(dataPurchases.rfmFrequent$SubCategoryDescription), aes(x = sub_ord_f)) +
  geom_bar() + labs(x = "Subcategoria de Produtos", y = "Freq") + labs(title = "Produtos por Clientes tipo 'Frequente'") + coord_flip()

```


Novamente se observa que os clusters apresentam similitudes, por exemplo, as subcategorias menos compradas são comuns aos três grupos. A subcategoria mais comprada pelos clientes dos tipos esporádico e regular é a mesma (Personal).


```{r include = FALSE}

plot(dataPurchases.rfmRegular$SubCategoryDescription, col=rainbow(11), horiz = TRUE)
plot(dataPurchases.rmfFrequent$SubCategoryDescription, col=rainbow(11), horiz = TRUE)
plot(dataPurchases.rfmSporadically$SubCategoryDescription, col=rainbow(11), horiz = TRUE)
```




## Análise do Cluster Clientes Tipo Regular
### Caraterização

Tal como nos restantes clusters, existem transações de todas as subcategorias de produtos.
```{r}

# Todas as subcategorias de produtos
levels(dataPurchases.rfmRegular$SubCategoryDescription)

# Número de vendas por subcategorias
baskets.subcat <- plyr::count(dataPurchases.rfmRegular, c("dataPurchases$SubCategoryDescription"))
colnames(baskets.subcat) <- c("subcategory", "freq")

baskets.subcat <- baskets.subcat[order(-baskets.subcat$freq), ]

length(unique(baskets.subcat$subcategory))       # 47 subcategorias 

# Número médio de itens por basket (subcategoria)
summary(baskets.subcat$freq)

```


### Visualização dos cinco primeiro cestos
```{r}

basket <- as(split(as.vector(dataPurchases.rfmFrequent$SubCategoryDescription), as.vector(dataPurchases.rfmRegular$CardID)), "transactions")

class(basket)
summary(basket)
dim(basket)

basket@itemInfo   # gives all the items of the basket

inspect(basket[1:5])

```


```{r}
# Suporte de cada item
itemFreq <- itemFrequency(basket)

# Produtos com mais suport3
sort(itemFreq, decreasing = T)[1:3]
summary(itemFreq)


# Produtos com suport superior a 20%
with(s <- 0.20,
  itemFrequencyPlot(basket, support = s)
)

```

Verifica-se que existem 8 produtos com suporte superior a 20%.


#Visualização da matriz de produtos comprados e respetiva dispersão.
```{r}
#image(basket[1:50])
image(sample(basket, 50)) # 50 linhas
```

#Algoritmo Apriori para extração de Regras de Associação 
#Sup min = 5% e Conf min = 80%
```{r}
sup.min = 0.10
conf.min = 0.60

basketRules <- apriori(basket, parameter = list(support = sup.min, confidence = conf.min, minlen = 2))
summary(basketRules)
```

```{r}
measures <- interestMeasure(basketRules, measure = c("coverage", "leverage", "conviction"), transactions = basket)

summary(measures)


# Top rules by lift
inspect(head(basketRules, n = 5, by = "lift"))

```


```{r}

basketRules2 <- apriori(basket, parameter = list(support = 0.01, confidence = 0.05, minlen = 2, maxlen = 20))

summary(basketRules2)

#plot rules with confidence on the y-axis
plot(basketRules2, measure = c("support", "confidence"), shading = "lift")

#plot rules with lift on the y-axis
plot(basketRules2, measure = c("support", "lift"), shading = "confidence")

#plot rules by number of items
plot(basketRules2, control = list(main = "Two-key plot"), shading = "order")

```



## Análise do Cluster Clientes Tipo Esporádico
### Caraterização

```{r}

# Todas as subcategorias de produtos
levels(dataPurchases.rfmSporadically$SubCategoryDescription)

# Número de vendas por subcategorias
baskets.subcat <- plyr::count(dataPurchases.rfmSporadically, c("dataPurchases$SubCategoryDescription"))
colnames(baskets.subcat) <- c("subcategory", "freq")

baskets.subcat <- baskets.subcat[order(-baskets.subcat$freq), ]

length(unique(baskets.subcat$subcategory))       # 47 subcategorias 

# Número médio de itens por basket (subcategoria)
summary(baskets.subcat$freq)

```


### Visualização dos cinco primeiros cestos
```{r}

basket <- as(split(as.vector(dataPurchases.rfmSporadically$SubCategoryDescription), as.vector(dataPurchases.rfmSporadically$CardID)), "transactions")

inspect(basket[1:5])

```


```{r}
# Suporte de cada item
itemFreq <- itemFrequency(basket)

# Produtos com mais suporte
sort(itemFreq, decreasing = T)[1:3]
summary(itemFreq)


# Produtos com suport superior a 20%
with(s <- 0.20,
  itemFrequencyPlot(basket, support = s)
)
```

Existem apenas três produtos com suporte superior a 20%, o que se não será surpreendente neste tipo de clientes.

###Algoritmo Apriori para extração de Regras de Associação 
```{r}
sup.min = 0.05
conf.min = 0.60

basketRules <- apriori(basket, parameter = list(support = sup.min, confidence = conf.min, minlen = 2))
summary(basketRules)
```

```{r}
measures <- interestMeasure(basketRules, measure = c("coverage", "leverage", "conviction"), transactions = basket)

summary(measures)

# Top rules by lift
inspect(head(basketRules, n = 5, by = "lift"))

```


```{r}

basketRules2 <- apriori(basket, parameter = list(support = 0.01, confidence = 0.05, minlen = 2, maxlen = 20))

summary(basketRules2)

#plot rules with confidence on the y-axis
plot(basketRules2, measure = c("support", "confidence"), shading = "lift")

#plot rules with lift on the y-axis
plot(basketRules2, measure = c("support", "lift"), shading = "confidence")

#plot rules by number of items
plot(basketRules2, control = list(main = "Two-key plot"), shading = "order")

```



## Análise do Cluster Clientes Tipo Frequente
### Caraterização

```{r}

# Todas as subcategorias de produtos
levels(dataPurchases.rfmFrequent$SubCategoryDescription)

# Número de vendas por subcategorias
baskets.subcat <- plyr::count(dataPurchases.rfmFrequent, c("dataPurchases$SubCategoryDescription"))
colnames(baskets.subcat) <- c("subcategory", "freq")

baskets.subcat <- baskets.subcat[order(-baskets.subcat$freq), ]

length(unique(baskets.subcat$subcategory))       # 47 subcategorias 

# Número médio de itens por basket (subcategoria)
summary(baskets.subcat$freq)

```


### Visualização dos cinco primeiros cestos
```{r}

basket <- as(split(as.vector(dataPurchases.rfmFrequent$SubCategoryDescription), as.vector(dataPurchases.rfmFrequent$CardID)), "transactions")

inspect(basket[1:5])

```


```{r}
# Suporte de cada item
itemFreq <- itemFrequency(basket)

# Produtos com mais suporte
sort(itemFreq, decreasing = T)[1:3]
summary(itemFreq)


# Produtos com suport superior a 20%
with(s <- 0.20,
  itemFrequencyPlot(basket, support = s)
)
```

Como seria expectável, o número de suportes com suporte a 20% (16) é superior ao dos outros grupos.

###Algoritmo Apriori para extração de Regras de Associação 
```{r}
sup.min = 0.20
conf.min = 0.80

basketRules <- apriori(basket, parameter = list(support = sup.min, confidence = conf.min, minlen = 2))
summary(basketRules)
```

```{r}
measures <- interestMeasure(basketRules, measure = c("coverage", "leverage", "conviction"), transactions = basket)

summary(measures)

# Top rules by lift
inspect(head(basketRules, n = 5, by = "lift"))

```


```{r}

basketRules2 <- apriori(basket, parameter = list(support = 0.01, confidence = 0.05, minlen = 2, maxlen = 20))

summary(basketRules2)

#plot rules with confidence on the y-axis
plot(basketRules2, measure = c("support", "confidence"), shading = "lift")

#plot rules with lift on the y-axis
plot(basketRules2, measure = c("support", "lift"), shading = "confidence")

#plot rules by number of items
plot(basketRules2, control = list(main = "Two-key plot"), shading = "order")

```


## Conclusões


# Vendas por categorias de produtos
```{r include = FALSE}
plot(dataPurchases$CategoryDescription, col=rainbow(11))

boxplot( Amount ~ CategoryDescription, data = dataPurchases, main = "Valor das Vendas por Categoria", col = rainbow(11), outline = TRUE)

barplot(table(dataPurchases$PaymentMethod, dataPurchases$CategoryDescription),
        beside = T, col = c("red", "green", "blue", "yellow"),
        main = "Métodos de Pagamento por Categoria", ylim = c(0, 120000))

legend("topright", levels(dataPurchases$PaymentMethod), bty = "n", fill=c("red", "green", "blue", "yellow"))

# Todas as categorias de produtos
levels(dataPurchases$CategoryDescription)

# Número de vendas por categorias
baskets.cat <- count(dataPurchases, c("dataPurchases$CategoryDescription"))
baskets.cat <- baskets.cat[order(-baskets.cat$freq), ]
colnames(baskets.cat) <- c("category", "freq")

length(unique(baskets.cat$category))       # 7 categorias 

# Número médio de itens por basket
summary(baskets.cat$freq)

```

