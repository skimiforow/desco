---
title: "DESCO - Knowledge Discovery - Association Rules"
author: "1141074 - Sérgio Silva | 1970400 - Pedro Neves | 1040706 - Sérgio Castro"
date: "5/3/2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Limpeza do ambiente

```{r Clean Environment, include=FALSE}
rm(list = ls())
```

#Bibliotecas necessárias
```{r}

library(data.table)
library(rfm)
library(lubridate)
library(dplyr)
library(ggplot2)

```


#Carregamento das tabelas de transações

The	 RFM	 (recency,	 frequency	 and	 monetary)	 model	 is	 the	 most	 widely	 used	 to	characterize customers	 because	 of its	 simplicity	and	good	 predictive	 capabilities.	 "Recency"	 represents	 the	time	since	the	last	purchase,	a	lower	value	corresponding	to	a	higher	probability	of	the	customer	making	a	repeat	 purchase.	 "Frequency"	 denotes	 the	 number	 of	 purchases	 within	 a	 specified	 time	 period;	 higher	frequency	indicates	higher	loyalty.	"Monetary"	means	 the	amount	of	money	spent	over this	specified	 time	period,	a	higher	value	indicates a	customer	that	the	company	should	focus on [2].

Loading of the tables to create model RFM
```{r Carregamento}
keycols <- c('Store', 'Date', 'Time', 'TransactionID')

transactions = fread('DATA-CRM/TRANSACTION.dat')
setkeyv(transactions, keycols)

trans.items = fread('DATA-CRM/TRANSACTION_ITEM.dat')
setkeyv(trans.items, keycols)

```

##Fazer 'join' das duas tabelas e remover observações contendo datas inválidas

```{r Merge}
result.transactions <- merge(transactions, trans.items, all = TRUE)
result.transactions[, Date := as.Date(as.character.Date(Date), "%Y%m%d")]
result.transactions <- na.omit(result.transactions, cols = "Date")
```


## Gerar RFM Score com package rfm

Calcula 'Recency', 'Frequency' e 'Monetary' a partir duma tabela de transações
```{r RFM algorithm}
analysis.date <- as.Date("2015-01-01")

orders <- result.transactions[, .(CardID, Date, Amount)]
rfm_result <- rfm_table_order(orders, CardID, Date, Amount, analysis.date)

summary(rfm_result)
str(rfm_result)

```

#1. Exploração e preparação dos dados

## Tabela CARD.dat
```{r CARD.dat}
cards = fread("DATA-CRM/CARD.dat", stringsAsFactors = TRUE)
```

### Verificação dos dados da tabela card, tal como o número de colunas e linhas, bem como se os dados foram corretamente carregados.
```{r}
summary(cards)
dim(cards)
str(cards)
nrow(cards[!complete.cases(cards), ])
```

### Tratar os dados nulos e errados nas colunas NumChildren e YoungestChild , pois tem valores negativos. No MaritalStatus há dados nulos que devem ser tratados também.

```{r}

cards[NumChildren < 0, NumChildren := 0]
cards[YoungestChild < 0, YoungestChild := 0]
  
# Como existem observações que indicam ter filhos, mas depois o campo do número de filhos está a 0, decidimos alterar o atributo "HasChildren" para "N"
cards[NumChildren == 0 & HasChildren == 'Y', .N]   #13
cards[NumChildren == 0 & HasChildren == 'Y', HasChildren := 'N']

# NumChildren > 0 e HasChildren
cards[NumChildren > 0 & HasChildren == 'N', .N]    #8138
cards[NumChildren > 0 & HasChildren == 'N', HasChildren := 'Y']

# Se não há filhos, colocar YoungestChild <- 0
cards[NumChildren == 0 & HasChildren == 'N', YoungestChild := 0]



# Verificamos que o MaritalStatus possui dados vazios
table(cards$MaritalStatus)

cards[MaritalStatus == "", MaritalStatus := "O"]
cards$MaritalStatus <- droplevels(cards$MaritalStatus)
```

### Verificar se a tabela Card possui dados nulos
```{r}
table(is.na(cards))
unique(cards)
table(duplicated(cards))

```


#2. Pré-processamento dos dados

## Dados dos clientes
```{r juntar dados dos clientes}
df_customers <- merge(cards, rfm_result$rfm[, c(1, 9)], by.x = 'CardID', by.y = 'customer_id')

df_customers[, CardStartDate := as.Date(as.character.Date(CardStartDate), "%Y%m%d")]
df_customers[, DateOfBirth := as.Date(as.character.Date(DateOfBirth), "%Y%m%d")]

```

```{r criar as colunas com idade e anos de cliente}

# Calcular Idade do cliente
yr = duration(num = 1, units = "years")
df_customers[, age := round(interval(DateOfBirth, analysis.date)/yr,digits = 0)]

# Anos de cliente
df_customers[, clientYears := round(interval(CardStartDate, analysis.date)/yr,digits = 0)]
```


```{r retirar id e código postal, CardStartDate e DateOfBirth}

#df_customers <- df_customers[, c(2,3,6,8:14)]

df_customers$Gender <- factor(df_customers$Gender, levels = c("F", "M"), labels = c("Feminino", "Masculino"))
df_customers$MaritalStatus <- factor(df_customers$MaritalStatus, levels = c("M", "S", "O"), labels = c("Casado", "Solteiro", "Outro"))
df_customers$HasChildren <- factor(df_customers$HasChildren, levels = c("Y", "N"), labels = c("Sim","Não"))

```

```{r}

df_customers$rfm_score_cat <- case_when(df_customers$rfm_score <= 233 ~ 'Sporadically',
                  between(df_customers$rfm_score, 234, 443) ~ 'Regular',
                  df_customers$rfm_score >= 444 ~ 'Frequent'
                  )

df_customers$rfm_score_cat <- as.factor(df_customers$rfm_score_cat)

df_customers$ageInterval <- cut(df_customers$age, 
                      breaks = c(0, 50, 65, +Inf), 
                      labels = c("< 50", "< 65", ">= 65"), 
                      right = FALSE)

summary(df_customers)
```


```{r}

summary(df_customers$clientYears)
# Amplitude de clientYears é pequena pelo que não será considerado

# CardID é mantido para permitir a identificação das transações depois
# da criação dos clusters; no entanto, não é utilizado para a criação dos clusters

dataCustomers <- df_customers[, c("CardID", "Region", "Gender", "MaritalStatus", "HasChildren", 
                                   "rfm_score_cat", "clientYears", "age", "ageInterval")]


with(dataCustomers,
  plot( ageInterval, rfm_score_cat, xlab = "Age", ylab = "RFM Score")
  )

```

# Clustering

##Model-based Clustering
```{r}
library(VarSelLCM)
set.seed(123)

# without ageInterval
out <- VarSelCluster(dataCustomers[1:1000, -c("CardID", "ageInterval")], gvals = 2, nbcores = 2)

VarSelShiny(out)
```


## Hierarchical Clustering
```{r}

#clusters <- hclust(dist(data[, 5]))
#plot(clusters)
#clusterCut <- cutree(clusters, 3)

library(cluster)
set.seed(123)

# without clientYears and age
gower.dist <- daisy(dataCustomers[1:10000, -c("CardID", "clientYears", "age")], metric = "gower")
summary(gower.dist)

gower.mat <- as.matrix(gower.dist)


# Output most similar pair
dataCustomers[
  which(gower.mat == min(gower.mat[gower.mat != min(gower.mat)]),
        arr.ind = TRUE)[1, ], ]

# Output most dissimilar pair
dataCustomers[
  which(gower.mat == max(gower.mat[gower.mat != max(gower.mat)]),
        arr.ind = TRUE)[1, ], ]


# Divisive (DIANA)
divisive.clust <- diana(as.matrix(gower.dist), 
                  diss = TRUE, keep.diss = TRUE)

plot(divisive.clust, main = "Divisive")

# Agglomerative (AGNES)

```


## Categorial clustering with k-modes algorithm
```{r}

library(klaR)

set.seed(123)

# Set number of clusters
kNumberClusters <- 3

# without age and clientYears
clusters.kmodes <- kmodes(dataCustomers[, -c("CardID", "age", "clientYears")], modes = kNumberClusters, iter.max = 10, weighted = FALSE)

# Place customer in its cluster
dataCustomers$cluster <- clusters.kmodes$cluster
clusters <- split(dataCustomers, dataCustomers$cluster)

dataCustomers[, .N, by = .(cluster, Gender)][order(cluster, Gender)]
dataCustomers[, .N, by = .(cluster, Region)][order(cluster, Region)]
dataCustomers[, .N, by = .(cluster, rfm_score_cat)][order(cluster, rfm_score_cat)]
```

```{r}
round(prop.table(table(clusters[[1]]$Region))*100, digits = 2)
round(prop.table(table(clusters[[1]]$Gender))*100, digits = 2)
round(prop.table(table(clusters[[1]]$MaritalStatus))*100, digits = 2)
round(prop.table(table(clusters[[1]]$HasChildren))*100, digits = 2)
round(prop.table(table(clusters[[1]]$rfm_score_cat))*100, digits = 2)
round(prop.table(table(clusters[[1]]$ageInterval))*100, digits = 2)
```

```{r}
round(prop.table(table(clusters[[2]]$Region))*100, digits = 2)
round(prop.table(table(clusters[[2]]$Gender))*100, digits = 2)
round(prop.table(table(clusters[[2]]$MaritalStatus))*100, digits = 2)
round(prop.table(table(clusters[[2]]$HasChildren))*100, digits = 2)
round(prop.table(table(clusters[[2]]$rfm_score_cat))*100, digits = 2)
round(prop.table(table(clusters[[2]]$ageInterval))*100, digits = 2)
```

```{r}
round(prop.table(table(clusters[[3]]$Region))*100, digits = 2)
round(prop.table(table(clusters[[3]]$Gender))*100, digits = 2)
round(prop.table(table(clusters[[3]]$MaritalStatus))*100, digits = 2)
round(prop.table(table(clusters[[3]]$HasChildren))*100, digits = 2)
round(prop.table(table(clusters[[3]]$rfm_score_cat))*100, digits = 2)
round(prop.table(table(clusters[[3]]$ageInterval))*100, digits = 2)
```

```{r}

barplot(table(dataCustomers$Region, dataCustomers$cluster),
        beside = T, col = c("red", "green"),
        main = "Region by cluster")

barplot(table(dataCustomers$Gender, dataCustomers$cluster),
        beside = T, col = c("red", "green"),
        main = "Gender by cluster")

barplot(table(dataCustomers$MaritalStatus, dataCustomers$cluster),
        beside = T, col = c("red", "green", "blue"),
        main = "MaritalStatus by cluster")

barplot(table(dataCustomers$rfm_score_cat, dataCustomers$cluster),
        beside = T, col = c("red", "green", "blue"),
        main = "RFM Score by cluster")

barplot(table(dataCustomers$HasChildren, dataCustomers$cluster),
        beside = T, col = c("red", "green"),
        main = "HasChildren by cluster")

barplot(table(dataCustomers$ageInterval, dataCustomers$cluster),
        beside = T, col = c("red", "green", "blue"),
        main = "Age by cluster")


```

```{r}
dataCustomers.cl1 <- dataCustomers[cluster == 1, .N, by = .(cluster, Gender)][order(cluster, Gender)]
```



## Dados das compras
```{r}

## Tabela ITEM.dat
items <- fread("DATA-CRM/ITEM.dat", quote = "'")

### Verificação dos dados da tabela item, tal como o número de colunas e linhas, bem como se os dados foram corretamente carregados.
summary(items)
dim(items)
str(items)

#Verificar se a tabela possui dados nulos
table(is.na(items))


## Tabelas CATEGORY.dat e SUBCATEGORY.dat
categories <- fread("DATA-CRM/CATEGORY.dat", quote = "'")
subcategories <- fread("DATA-CRM/SUBCATEGORY.dat", quote = "'")


```

# Join com a tabela de transações + cardID
```{r}

result.aux <- merge(items, categories, all.x = TRUE, by = 'CategoryCode')
result.aux <- merge(result.aux, subcategories, all.x = TRUE, by = 'SubCategoryCode')

result.purchases <- merge(result.transactions, result.aux[ ,c(3:5, 7:8)], all.x = TRUE, by = 'ItemCode')

# Se retirados 'ItemNumber' e 'TransactionID' passam a existir observações repetidas
dataPurchases <- result.purchases[, c("CardID", "Date", "PaymentMethod", "Amount", "ItemDescription", "CategoryDescription", "SubCategoryDescription", "BrandCode", "ItemNumber", "TransactionID")]

```

#Determine Best Number of Clusters in Customers Data Set
```{r}
#library(NbClust)
#library(cluster)

#set.seed(123)

#gower.dist <- daisy(dataCustomers[1:1000, ], metric = "gower")

#nb <- NbClust(diss = gower.dist, distance = NULL, min.nc = 2,
#        max.nc = 10, method = "complete", index ="all")
```







```{r}
library("plyr")

dataPurchases$PaymentMethod <- as.factor(dataPurchases$PaymentMethod)
dataPurchases$ItemDescription <- as.factor(dataPurchases$ItemDescription)
dataPurchases$CategoryDescription <- as.factor(dataPurchases$CategoryDescription)
dataPurchases$SubCategoryDescription <- as.factor(dataPurchases$SubCategoryDescription)
dataPurchases$BrandCode <- as.factor(dataPurchases$BrandCode)

head(dataPurchases)
str(dataPurchases)

```


# Vendas por subcategorias de produtos
```{r}
plot(dataPurchases$SubCategoryDescription, col=rainbow(11))

# Todas as subcategorias de produtos
levels(dataPurchases$SubCategoryDescription)

# Número de vendas por subcategorias
baskets.subcat <- count(dataPurchases, c("dataPurchases$SubCategoryDescription"))
baskets.subcat <- baskets.subcat[order(-baskets.subcat$freq), ]
colnames(baskets.subcat) <- c("subcategory", "freq")

length(unique(baskets.subcat$subcategory))       # 47 subcategorias 

# Número médio de itens por basket (subcategoria)
summary(baskets.subcat$freq)

```

# Vendas por categorias de produtos
```{r}
plot(dataPurchases$CategoryDescription, col=rainbow(11))

boxplot( Amount ~ CategoryDescription, data = dataPurchases, main = "Valor das Vendas por Categoria", col = rainbow(11), outline = TRUE)

barplot(table(dataPurchases$PaymentMethod, dataPurchases$CategoryDescription),
        beside = T, col = c("red", "green", "blue", "yellow"),
        main = "Métodos de Pagamento por Categoria", ylim = c(0, 120000))

legend("topright", levels(dataPurchases$PaymentMethod), bty = "n", fill=c("red", "green", "blue", "yellow"))

# Todas as categorias de produtos
levels(dataPurchases$CategoryDescription)

# Número de vendas por categorias
baskets.cat <- count(dataPurchases, c("dataPurchases$CategoryDescription"))
baskets.cat <- baskets.cat[order(-baskets.cat$freq), ]
colnames(baskets.cat) <- c("category", "freq")

length(unique(baskets.cat$category))       # 7 categorias 

# Número médio de itens por basket
summary(baskets.cat$freq)

```

```{r}
library(arules)

basket <- as(split(as.vector(dataPurchases$SubCategoryDescription), as.vector(dataPurchases$CardID)), "transactions")

class(basket)
summary(basket)
dim(basket)

basket@itemInfo   # gives all the items of the basket

#View the first five transactions
inspect(basket[1:5])

```


```{r}
# Occurrences of each item - Support
itemFreq <- itemFrequency(basket)

sort(itemFreq, decreasing = T)
summary(itemFreq)

#View the frequency of the first three items
itemFrequency(basket[, 1:3])

#Shows in a histogram plot items with at least s support
with(s <- 0.20,
  itemFrequencyPlot(basket, support = s)
)
```

#Visualização da matriz de produtos comprados e respetiva dispersão.
```{r}
#image(basket[1:50])
image(sample(basket, 50)) # 50 linhas
```

#Algoritmo Apriori para extração de Regras de Associação 
#Sup min = 5% e Conf min = 80%
```{r}
sup.min = 0.05
conf.min = 0.80

basketRules <- apriori(basket, parameter = list(support = sup.min, confidence = conf.min, minlen = 2))
summary(basketRules)
```

```{r}
measures <- interestMeasure(basketRules, measure = c("coverage", "leverage", "conviction"), transactions = basket)

summary(measures)


# Top rules by lift
inspect(head(basketRules, n = 5, by = "lift"))

```


```{r}
library(arulesViz)

basketRules2 <- apriori(basket, parameter = list(support = 0.01, confidence = 0.05, minlen = 2))

summary(basketRules2)
```
